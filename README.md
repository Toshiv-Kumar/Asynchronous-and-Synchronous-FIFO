# Asynchronous-and-Synchronous-FIFO
Designed Synchronous and Asynchronous FIFO in Verilog HDL and verified the design using a simple testbench. January 2026



***
# Theory
# Basics of CDC
<img width="1321" height="785" alt="image" src="https://github.com/user-attachments/assets/f99dcbb7-1975-4212-8d2d-35d2a57a4d98" />
## Difference between Synchronous and Asynchronous Designs:
1. **Synchronous:** If all the modules/subsystems of an IP are running on the same clock frequency and same phase then the design is called synchronous. A module transfers data/signal through the same clock as the module which accepts the data.
2.  **Asynchronous:** If the multiple modules work on different clocks within the same IP, or even if there are 2 IPs and the IPs work on different clocks and transfer of data/signal happens, then it is called asynchronous design. Example-: Module A transfers data at CLK i to another module B which accepts data through CLK j. CLK i and j differ either by frequency or phase as they were generated by different PLLs in the chip. This passing of data/signal is called **clock domain crossing.**

## Metastability and MTBF(Mean Time between Failures)
<img width="1405" height="851" alt="image" src="https://github.com/user-attachments/assets/5584954b-639c-4f7c-bd7b-01f26c5b4b1e" />

### Metastability
If the SigA which is the ouput of module(having clkA) changes very close to CLKB's sampling edge then it may not entirely cover up the setup or hold time window of clkB and hence the output would be undeterministic(near Vdd/2 that is neither high nor low) for a period of time as it wasn't sampled correctly/entirely until the next clock edge of B where it is sampled correctly if it remains as it is and does not change. This metastability region is called **Failure**
See CMOS Prof.Janakiraman for setup and hold time intuition.
In short-: Why setup time is needed? Master Latch is on before the sampling edge and it needs to store the new incoming data in the feedback loop as the feedback loop will turn on closing the data input path. The time delay of all the inverters and pass transmission gates it needs to pass through till it reaches the last transmission gate of **Breaking the FB configuration.** is the setup time.
Hold time is required in case of clock skew(on clkbar-: negative skew in +ve edge trigger) in case of 1-1 overlap of clk and clkbar where data can shoot through both the latch's transmission gates if data changes during the thold, this is a race condition.

### MTBF
Is is inversely proportional to (sampling frequency(of data acceptor clock)* frequency of change of data), obviously as if the input change increases then more likely that it will change within setup or hold window and failure/metastabillity will happen.

CDC Techniques discussed further help in increasing MTBF time.

## Technique to increase MTBF-: 2 Stage/flop synchronizers for a level signal(frequency = 1Hz))
<img width="905" height="562" alt="image" src="https://github.com/user-attachments/assets/5a31a389-bdec-44b0-9c75-74997cbe6d12" />

Here we can see that the capture flop which has the output of **o/p** is initially caught in metastablity but the 2nd cascaded flop right next to it does not capture this unstable data as 2 D-FF cascaded work like shift registers and hence the 2nd flop captures the previous data that was there before the edge. 
On the next edge both o/p and 2nd flop capture the correct value as the o/p actually slowly rises/falls to the correct value during the metastablity state(as the state is temporary) and the 2nd flop that accepts the value has the inverter logic gate initially which produces the correct output as the input lies either in the Vil or Vih range.

### Actual design Implementation:

<img width="863" height="507" alt="image" src="https://github.com/user-attachments/assets/7f93ac62-ff19-4e52-b170-ccaec7113ca2" />
We should pull this from std.cell library as the distance between the 2 flops should be less. If the distance is more, then the o/p signal of 1st flop may diminish its logic value.(This is primarily why buffers are added in a design of clock tree).

# Edge Dectection Logic/Ckt to generate a pulse signal from a level signal
<img width="1180" height="721" alt="image" src="https://github.com/user-attachments/assets/10f03087-09fe-419b-9a0d-cc23a6f94a60" />
3 types of pulse generation-:
1. Positive Edge Detection
2. Negative Edge Dectecton
3. Both Implement together
Note-: **Positive edge detection means that want to generate a pulse on the positive edge of the input signal.**
For this we use an additional D flop to produce the delayed version of Signal A(If Sig A and posedge of clock occurs at the same time then the previous value of SigA is sampled instead of new value). We use the logic equation as shown to generate a small pulse using additional gates.

## Ckt Implementation
<img width="898" height="545" alt="image" src="https://github.com/user-attachments/assets/9b330bac-fc29-4030-b5da-a3926dace672" />

# Pulse Synchronizer: Transferring of Pulse from slower to faster or faster to slower clock domains.
**1) Slow to Fast:**
<img width="835" height="462" alt="image" src="https://github.com/user-attachments/assets/6761ec55-f695-4e54-a7b4-d4e8b13408d9" />

**Defination of Pulse:**
When logic level 1 lasts for a complete 1 time period and then shuts off, it is then called a pulse.
In the Figure when we pass the SignalA pulse(pulse in ClkA) to the clock domain B's flop though double synchronizers we actually get a level in clkB(logic '1' lasts for multiple clocks) hence we use the edge detection technique to produce a pulse in clkB.
Do note that this design fails if clkA and clkB are very near in frequency in case the sampled SigB goes into metastability. Better approach discussed later.

<img width="657" height="412" alt="image" src="https://github.com/user-attachments/assets/0c080a8c-b0c6-49c5-b0e3-b15a367efbb1" />


**2) Fast to Slow clock:** 
<img width="687" height="461" alt="image" src="https://github.com/user-attachments/assets/ca231a72-1574-4b3f-8433-cfad07b33ea5" />

Here you can see that pulse is not detected as it was never sampled. We can either use Toggle based approach/Handshake(standard and usable if we don't know the frequency of both clocks) based approach.

<img width="766" height="536" alt="image" src="https://github.com/user-attachments/assets/e0860ecd-952f-49cb-a9fe-82a2e5389978" />

here we convert the small pulse into level that is easily detectable through slow clockB. Edge detection technique is used to generate pulses in clock B.
Issue arises when multiple pulses are generated in clkA domain as double synchronizer will miss out some of these pulses due to metastability of the previous pulse and also the fact that they are in slower clkB.
